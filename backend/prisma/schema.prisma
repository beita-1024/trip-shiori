// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 参考: Prisma Schemaの書き方あれこれ
// https://zenn.dev/ikekyo/scraps/f6c87fbfd3bf9d

/**
 * ユーザー情報を管理するモデル
 * 
 * 各ユーザーは一意のIDとメールアドレスを持ち、パスワードハッシュや認証状態を保持します。
 * 行程（Itinerary）やメール認証トークンとのリレーションを持ちます。
 * 作成日時・更新日時は自動管理されます。
 */
model User {
  /** ユーザーの一意識別子 */
  id            String   @id @default(cuid())

  /** メールアドレス（ユニーク） */
  email         String   @unique

  /** パスワードのハッシュ値 */
  passwordHash  String

  /** 表示名（任意） */
  name          String?

  /** メール認証日時（未認証ならnull） */
  emailVerified DateTime?

  /** パスワード変更日時（JWT無効化用） */
  passwordChangedAt DateTime?

  /** 作成日時 */
  createdAt     DateTime @default(now())

  /** 更新日時（自動更新） */
  updatedAt     DateTime @updatedAt

  /** ユーザーが所有する行程リスト */
  itineraries   Itinerary[]

  /** メール認証トークンとのリレーション */
  emailVerificationTokens EmailVerificationToken[]

  /** パスワードリセットトークンとのリレーション */
  passwordResetTokens     PasswordResetToken[]
}

/**
 * 旅行の行程を管理するモデル
 * 
 * 各行程は一意のIDを持ち、行程データをJSON形式のテキストとして保存します。
 * 作成日時と更新日時は自動的に管理されます。
 */
model Itinerary {
  /** 行程の一意識別子 */
  id        String   @id @db.VarChar(255)

  /** 行程データ（JSON形式のテキスト） */
  // NOTE: 行程データはLLM APIで扱いやすいように正規化せずにJsonのまま保存する。
  data      String?  @db.Text

  /** 作成日時 */
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  /** 更新日時（自動更新） */
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  // TODO: 注意！認証機能を実装したらオプショナルを外すこと！
  /** 所有者のユーザーID（認証機能実装前はオプショナル） */
  userId    String? 

  // TODO: 注意！認証機能を実装したらオプショナルを外すこと！
  /** 所有者のユーザー（認証機能実装前はオプショナル） */
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  /** 共有設定（1対1） */
  share     ItineraryShare?

  @@index([userId, updatedAt])
  @@index([userId, createdAt])
  @@index([updatedAt]) // 所有者なし旅程の検索用
  @@index([createdAt]) // 所有者なし旅程の検索用
}


 /**
  * メール認証トークンを管理するモデル
  * 
  * 各トークンは一意のIDとハッシュ化されたトークン値を持ち、ユーザーと紐付けられます。
  * 有効期限・作成日時を保持し、トークンはユニーク制約付きです。
  * インデックスにより検索性能を最適化しています。
  */
model EmailVerificationToken {
  /** トークンの一意識別子 */
  id         String   @id @default(cuid())

  /** 紐付くユーザーID */
  userId     String

  /** ハッシュ化されたトークン値（ユニーク） */
  tokenHash  String   @unique

  /** 有効期限 */
  expiresAt  DateTime

  /** 作成日時 */
  createdAt  DateTime @default(now())

  /** ユーザーとのリレーション（削除時はカスケード） */
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([tokenHash])
}

/**
 * パスワードリセットトークンを管理するモデル
 * 
 * 各トークンは一意のIDとハッシュ化されたトークン値を持ち、ユーザーと紐付けられます。
 * 有効期限・作成日時を保持し、トークンはユニーク制約付きです。
 * ユーザー毎に1件のみの制約により競合状態を防止します。
 * インデックスにより検索性能を最適化しています。
 */
model PasswordResetToken {
  /** トークンの一意識別子 */
  id         String   @id @default(cuid())

  /** 紐付くユーザーID（ユニーク制約により1ユーザー1トークン） */
  userId     String   @unique

  /** ハッシュ化されたトークン値（ユニーク） */
  tokenHash  String   @unique

  /** 有効期限 */
  expiresAt  DateTime @db.Timestamptz(6)

  /** 作成日時 */
  createdAt  DateTime @default(now()) @db.Timestamptz(6)

  /** ユーザーとのリレーション（削除時はカスケード） */
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@index([tokenHash])
  // 検索最適化：最新・未失効の取得パターンに合わせた複合Index
  @@index([userId, expiresAt, createdAt])
}

/**
 * 旅程の共有設定を管理するモデル
 * 
 * 各旅程に対して共有設定（公開リンク、権限、有効期限など）を管理します。
 * 所有者のない旅程でも共有設定によりアクセス制御が可能です。
 * 共有が無効化された場合や旅程が削除された場合は自動的にクリーンアップされます。
 */
model ItineraryShare {
  /** 共有設定の一意識別子 */
  id           String   @id @default(cuid())

  /** 共有対象の旅程ID */
  itineraryId  String

  /** 共有権限レベル */
  permission   SharePermission @default(READ_ONLY)

  /** 共有パスワード（ハッシュ化済み、オプション） */
  passwordHash String?

  /** 有効期限（nullの場合は無期限） */
  expiresAt    DateTime?

  /** 公開範囲 */
  scope        ShareScope @default(PUBLIC_LINK)

  /** 許可されたメールアドレスリスト（JSON配列、RESTRICTED_EMAILS時のみ使用） */
  // INFO: Prismaでは、配列型を直接サポートしていないデータベース（PostgreSQL以外）との互換性を保つため、配列をJSON文字列として保存する設計が一般的とのこと
  allowedEmails String?   @db.Text
  // TODO: メールの配列を別テーブルに正規化するかは要検討、実装しないと判断するまで残す
  // allowedEmails ItineraryShareEmail[]
 
  /** 共有開始日時 */
  createdAt    DateTime @default(now())

  /** 共有設定の更新日時 */
  updatedAt    DateTime @updatedAt

  /** 共有対象の旅程 */
  itinerary    Itinerary @relation(fields: [itineraryId], references: [id], onDelete: Cascade)

  /** アクセス回数 */
  accessCount    Int      @default(0)

  /** 最終アクセス日時 */
  lastAccessedAt DateTime?

  @@unique([itineraryId])
  @@index([expiresAt])
  @@index([scope])
}

// TODO: メールの配列を別テーブルに正規化するかは要検討、実装しないと判断するまで残す
// model ItineraryShareEmail {
//   id        String   @id @default(cuid())
//   shareId   String
//   email     String
//   createdAt DateTime @default(now())
//   
//   share     ItineraryShare @relation(fields: [shareId], references: [id], onDelete: Cascade)
//   
//   @@unique([shareId, email])
//   @@index([email])
// }

/**
 * 共有権限の列挙型
 */
enum SharePermission {
  /** 読み取り専用 */
  READ_ONLY
  /** 編集可能 */
  EDIT
}

/**
 * 公開範囲の列挙型
 */
enum ShareScope {
  /** リンクを知っている人全員（現在の仕様） */
  PUBLIC_LINK
  /** 特定のメールアドレスリストのみ */
  RESTRICTED_EMAILS
  /** 認証済みユーザーのみ */
  AUTHENTICATED_USERS
  /** 全体公開（検索エンジンにインデックスされ、誰でもアクセス可能） */
  // PUBLIC設定に関しては実装はしても、しばらくWebUI設定できないように隠すようにする。
  PUBLIC
}
