---
description: Python Coding Rules
globs:
  - "*.py"
  - "*.ipynb"
alwaysApply: true
---

# Python Coding Rules

## 基本原則

### 1. 型ヒントは必須
- すべての関数、メソッド、変数に型ヒントを付ける
- `typing` モジュールを適切に使用する
- `Optional`, `Union`, `List`, `Dict`, `Any` などを活用する

```python
# ✅ Good
def process_data(data: List[Dict[str, Any]]) -> Optional[str]:
    """データを処理して結果を返す"""
    if not data:
        return None
    return "processed"

# ❌ Bad
def process_data(data):
    if not data:
        return None
    return "processed"
```

### 2. Pydanticモデルの活用
- データ構造はPydanticモデルで定義する
- バリデーションとシリアライゼーションを活用する
- 設定管理には `BaseSettings` を使用する

```python
# ✅ Good
from pydantic import BaseModel, Field, validator
from typing import Optional, List

class User(BaseModel):
    id: int = Field(..., description="ユーザーID")
    name: str = Field(..., min_length=1, max_length=100)
    email: str = Field(..., regex=r'^[\w\.-]+@[\w\.-]+\.\w+$')
    tags: List[str] = Field(default_factory=list)
    
    @validator('name')
    def name_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('名前は空にできません')
        return v.strip()

# ❌ Bad
class User:
    def __init__(self, id, name, email, tags=None):
        self.id = id
        self.name = name
        self.email = email
        self.tags = tags or []
```

### 3. ドキュメントコメントは必須
- すべての関数、クラス、モジュールにdocstringを記述
- Googleスタイルのdocstringを使用
- 型情報、引数、戻り値、例外を明記

```python
# ✅ Good
def calculate_tax(amount: float, rate: float = 0.1) -> float:
    """税金を計算する
    
    Args:
        amount: 課税対象金額
        rate: 税率（デフォルト: 0.1）
        
    Returns:
        計算された税金額
        
    Raises:
        ValueError: amountが負の値の場合
        
    Example:
        >>> calculate_tax(1000, 0.1)
        100.0
    """
    if amount < 0:
        raise ValueError("金額は負の値にできません")
    return amount * rate

# ❌ Bad
def calculate_tax(amount, rate=0.1):
    return amount * rate
```

## コーディング規約

### 1. インポート順序
```python
# 1. 標準ライブラリ
import os
import sys
from typing import List, Dict, Optional

# 2. サードパーティライブラリ
import requests
from pydantic import BaseModel

# 3. ローカルアプリケーション
from .models import User
from .utils import helper_function
```

### 2. エラーハンドリング
```python
# ✅ Good
from typing import Optional

def safe_divide(a: float, b: float) -> Optional[float]:
    """安全な除算を実行する
    
    Args:
        a: 被除数
        b: 除数
        
    Returns:
        除算結果、またはゼロ除算の場合はNone
    """
    try:
        return a / b
    except ZeroDivisionError:
        return None

# ❌ Bad
def safe_divide(a, b):
    return a / b
```

### 3. 環境変数と設定管理
```python
# ✅ Good
from pydantic import BaseSettings, Field
from typing import Optional

class Settings(BaseSettings):
    """アプリケーション設定"""
    
    api_key: str = Field(..., description="APIキー")
    model_name: str = Field(default="gpt-4o-mini", description="使用するモデル名")
    debug: bool = Field(default=False, description="デバッグモード")
    max_retries: int = Field(default=3, ge=1, le=10, description="最大リトライ回数")
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

# 使用例
settings = Settings()
```

### 4. 非同期処理
```python
# ✅ Good
import asyncio
from typing import List, Dict, Any
import aiohttp

async def fetch_data(urls: List[str]) -> List[Dict[str, Any]]:
    """複数のURLからデータを非同期で取得する
    
    Args:
        urls: 取得するURLのリスト
        
    Returns:
        取得したデータのリスト
    """
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_single_url(session, url) for url in urls]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return [r for r in results if not isinstance(r, Exception)]

async def fetch_single_url(session: aiohttp.ClientSession, url: str) -> Dict[str, Any]:
    """単一URLからデータを取得する"""
    async with session.get(url) as response:
        return await response.json()
```

### 5. ログ出力
```python
# ✅ Good
import logging
from typing import Optional

logger = logging.getLogger(__name__)

def process_user_data(user_id: int, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """ユーザーデータを処理する
    
    Args:
        user_id: ユーザーID
        data: 処理するデータ
        
    Returns:
        処理結果、またはエラーの場合はNone
    """
    logger.info(f"ユーザー {user_id} のデータ処理を開始")
    
    try:
        # データ処理ロジック
        result = {"processed": True, "user_id": user_id}
        logger.info(f"ユーザー {user_id} のデータ処理が完了")
        return result
        
    except Exception as e:
        logger.error(f"ユーザー {user_id} のデータ処理でエラー: {e}")
        return None
```

## 禁止事項

### 1. 型ヒントなしの関数定義
```python
# ❌ Bad
def process_data(data):
    return data

# ✅ Good
def process_data(data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """データを処理する"""
    return data
```

### 2. ドキュメントコメントなしの関数
```python
# ❌ Bad
def calculate_total(items):
    return sum(item.price for item in items)

# ✅ Good
def calculate_total(items: List[Item]) -> float:
    """アイテムの合計金額を計算する
    
    Args:
        items: アイテムのリスト
        
    Returns:
        合計金額
    """
    return sum(item.price for item in items)
```

### 3. 生の辞書・リストの使用
```python
# ❌ Bad
def create_user(data):
    return {
        "id": data["id"],
        "name": data["name"],
        "email": data["email"]
    }

# ✅ Good
from pydantic import BaseModel

class UserCreate(BaseModel):
    """ユーザー作成用のデータモデル"""
    name: str = Field(..., min_length=1)
    email: str = Field(..., regex=r'^[\w\.-]+@[\w\.-]+\.\w+$')

def create_user(data: UserCreate) -> User:
    """ユーザーを作成する"""
    return User(**data.dict())
```

## テスト規約

### 1. テストファイルの命名
- テストファイルは `test_` プレフィックスを付ける
- テストクラスは `Test` プレフィックスを付ける

### 2. テスト関数の命名
```python
# ✅ Good
def test_calculate_tax_with_valid_input():
    """有効な入力での税金計算テスト"""
    assert calculate_tax(1000, 0.1) == 100.0

def test_calculate_tax_with_negative_amount():
    """負の金額での税金計算テスト"""
    with pytest.raises(ValueError):
        calculate_tax(-100, 0.1)
```

### 3. フィクスチャの使用
```python
# ✅ Good
import pytest
from pydantic import BaseModel

class TestUser(BaseModel):
    name: str
    email: str

@pytest.fixture
def sample_user() -> TestUser:
    """テスト用のユーザーデータ"""
    return TestUser(name="テストユーザー", email="test@example.com")

def test_user_creation(sample_user: TestUser):
    """ユーザー作成のテスト"""
    assert sample_user.name == "テストユーザー"
    assert sample_user.email == "test@example.com"
```

## パフォーマンス考慮事項

### 1. リスト内包表記の活用
```python
# ✅ Good
squares = [x**2 for x in range(10) if x % 2 == 0]

# ❌ Bad
squares = []
for x in range(10):
    if x % 2 == 0:
        squares.append(x**2)
```

### 2. ジェネレータの使用
```python
# ✅ Good
def read_large_file(filename: str) -> Iterator[str]:
    """大きなファイルを効率的に読み込む"""
    with open(filename, 'r') as f:
        for line in f:
            yield line.strip()

# 使用例
for line in read_large_file("large_file.txt"):
    process_line(line)
```

## セキュリティ考慮事項

### 1. 機密情報の管理
```python
# ✅ Good
from pydantic import SecretStr, BaseSettings

class DatabaseConfig(BaseSettings):
    """データベース設定"""
    host: str
    port: int = 5432
    username: str
    password: SecretStr
    database: str
    
    class Config:
        env_file = ".env"

# ❌ Bad
DATABASE_PASSWORD = "plaintext_password"
```

### 2. 入力値の検証
```python
# ✅ Good
from pydantic import BaseModel, validator
from typing import Optional

class UserInput(BaseModel):
    """ユーザー入力の検証"""
    email: str
    age: Optional[int] = None
    
    @validator('email')
    def validate_email(cls, v):
        if '@' not in v:
            raise ValueError('有効なメールアドレスを入力してください')
        return v.lower()
    
    @validator('age')
    def validate_age(cls, v):
        if v is not None and (v < 0 or v > 150):
            raise ValueError('年齢は0-150の範囲で入力してください')
        return v
```

これらの規約に従うことで、保守性が高く、型安全で、ドキュメント化されたPythonコードを書くことができます。